// Â© 2023 27 Software
//
// ************************************************************************
// Author           : DXterity8 Version 8.6
// Created          : October 14, 2023 10:21:15 AM
// File             : KnightsTourQuery.cs
// ************************************************************************

using System;
using System.Collections.Generic;

using GraphQL.Types;
using WebAPI.GraphQL.Types;

namespace WebAPI.GraphQL
{
    /// <summary>
    /// GraphQL query model.
    /// Generated On: October 14, 2023 at 10:21:15 AM by DXterity Solutions.
    /// Generated By: DXterity8 Version 8.6.0 (see https://dxteritysolutions.com/).
    /// </summary>
    public class KnightsTourQuery : ObjectGraphType<object>
    {
        #region Constructor(s)

        /// <summary>
        /// Initializes a new instance of the <see cref="KnightsTourQuery"/> class.
        /// Query configuration for KnightsTour.
        /// </summary>
        /// <param name="data">The data model assiciated with the GraphQL Schema.</param>
        public KnightsTourQuery(KnightsTourData data)
        {
            Name = "Query";

            #region Board related
            // Single board.
            Field<BoardType>(
                name: "board",
                description: "Returns a single Board based on the primary key identifier",
                arguments: new QueryArguments(
                    new QueryArgument<NonNullGraphType<IntGraphType>> { Name = "id", Description = "id of the board" }
                ),
                resolve: context => data.GetBoardByIdAsync(context.GetArgument<int?>("id"))
            );

            // Multiple boards.
            Field<ListGraphType<BoardType>>(
                name: "boards",
                description: "Returns a list of Boards records given the optional filters",
                arguments: new QueryArguments(
                    new QueryArgument<StringGraphType>() { Name = "where", Description = "The SQL where clause to be applied." },
                    new QueryArgument<StringGraphType>() { Name = "orderBy", Description = "The SQL order by clause to be applied, can be complex (mutiple columns, directions)." },
                    new QueryArgument<IntGraphType>() { Name = "take", Description = "The number of boards to return - typically used to limit or paginate results."},
                    new QueryArgument<IntGraphType>() { Name = "skip", Description = "The numer of boards to skip (typically used for pagination)." },
                    new QueryArgument<ListGraphType<TableJoinInput>>() { Name = "tableJoins", Description = "The optional tables that this query joins on." }
                ),
                resolve: context => data.GetBoards(
                    context.GetArgument<string>("where"),
                    context.GetArgument<string>("orderBy"),
                    context.GetArgument<int?>("take"),
                    context.GetArgument<int?>("skip"),
                    context.GetArgument<List<KnightsTour.CoreLibrary.TableJoin>>("tableJoins"))
            );

            // Board Count.
            Field<IntGraphType>(
                name: "boardCount",
                description: "The numer of Board records given the optional where clause",
                arguments: new QueryArguments(
                    new QueryArgument<StringGraphType>() { Name = "where", Description = "The optional where clause to filter on" },
                    new QueryArgument<ListGraphType<TableJoinInput>>() { Name = "tableJoins", Description = "The optional tables that this query joins on." }
                ),
                resolve: context => data.GetBoardCount(
                    context.GetArgument<string>("where"),
                    context.GetArgument<List<KnightsTour.CoreLibrary.TableJoin>>("tableJoins"))
            );

            // Distinct board field grouping.
            Field<ListGraphType<GroupDetailType>>(
                name: "boardDistinctValues",
                description: "Returns a distinct list of column data for the specified column also applying the optional where clause",
                arguments: new QueryArguments(
                    new QueryArgument<StringGraphType>() { Name = "keyName", Description = "The column to return a distinct list of" },
                    new QueryArgument<StringGraphType>() { Name = "where", Description = "The optional where clause to filter on" },
                    new QueryArgument<ListGraphType<TableJoinInput>>() { Name = "tableJoins", Description = "The optional tables that this query joins on." },
                    new QueryArgument<StringGraphType>() { Name = "fkTable", Description = "The optional foreign key table name" },
                    new QueryArgument<StringGraphType>() { Name = "fkColumn", Description = "The optional foreign key column name in which to join" },
                    new QueryArgument<StringGraphType>() { Name = "fkProperty1Name", Description = "The optional foreign key primary property name" },
                    new QueryArgument<StringGraphType>() { Name = "fkProperty2Name", Description = "The optional foreign key secondary property name" }
                ),
                resolve: context => data.GetBoardDistinctValues(
                    context.GetArgument<string>("keyName"),
                    context.GetArgument<string>("where"),
                    context.GetArgument<List<KnightsTour.CoreLibrary.TableJoin>>("tableJoins"),
                    context.GetArgument<string>("fkTable"),
                    context.GetArgument<string>("fkColumn"),
                    context.GetArgument<string>("fkProperty1Name"),
                    context.GetArgument<string>("fkProperty2Name"))
            );
            #endregion

            #region DifficultyLevel related
            // Single difficulty level.
            Field<DifficultyLevelType>(
                name: "difficultyLevel",
                description: "Returns a single Difficulty level based on the primary key identifier",
                arguments: new QueryArguments(
                    new QueryArgument<NonNullGraphType<IntGraphType>> { Name = "id", Description = "id of the difficulty level" }
                ),
                resolve: context => data.GetDifficultyLevelByIdAsync(context.GetArgument<int?>("id"))
            );

            // Multiple difficulty levels.
            Field<ListGraphType<DifficultyLevelType>>(
                name: "difficultyLevels",
                description: "Returns a list of Difficulty levels records given the optional filters",
                arguments: new QueryArguments(
                    new QueryArgument<StringGraphType>() { Name = "where", Description = "The SQL where clause to be applied." },
                    new QueryArgument<StringGraphType>() { Name = "orderBy", Description = "The SQL order by clause to be applied, can be complex (mutiple columns, directions)." },
                    new QueryArgument<IntGraphType>() { Name = "take", Description = "The number of difficulty levels to return - typically used to limit or paginate results."},
                    new QueryArgument<IntGraphType>() { Name = "skip", Description = "The numer of difficulty levels to skip (typically used for pagination)." },
                    new QueryArgument<ListGraphType<TableJoinInput>>() { Name = "tableJoins", Description = "The optional tables that this query joins on." }
                ),
                resolve: context => data.GetDifficultyLevels(
                    context.GetArgument<string>("where"),
                    context.GetArgument<string>("orderBy"),
                    context.GetArgument<int?>("take"),
                    context.GetArgument<int?>("skip"),
                    context.GetArgument<List<KnightsTour.CoreLibrary.TableJoin>>("tableJoins"))
            );

            // Difficulty level Count.
            Field<IntGraphType>(
                name: "difficultyLevelCount",
                description: "The numer of Difficulty level records given the optional where clause",
                arguments: new QueryArguments(
                    new QueryArgument<StringGraphType>() { Name = "where", Description = "The optional where clause to filter on" },
                    new QueryArgument<ListGraphType<TableJoinInput>>() { Name = "tableJoins", Description = "The optional tables that this query joins on." }
                ),
                resolve: context => data.GetDifficultyLevelCount(
                    context.GetArgument<string>("where"),
                    context.GetArgument<List<KnightsTour.CoreLibrary.TableJoin>>("tableJoins"))
            );

            // Distinct difficulty level field grouping.
            Field<ListGraphType<GroupDetailType>>(
                name: "difficultyLevelDistinctValues",
                description: "Returns a distinct list of column data for the specified column also applying the optional where clause",
                arguments: new QueryArguments(
                    new QueryArgument<StringGraphType>() { Name = "keyName", Description = "The column to return a distinct list of" },
                    new QueryArgument<StringGraphType>() { Name = "where", Description = "The optional where clause to filter on" },
                    new QueryArgument<ListGraphType<TableJoinInput>>() { Name = "tableJoins", Description = "The optional tables that this query joins on." },
                    new QueryArgument<StringGraphType>() { Name = "fkTable", Description = "The optional foreign key table name" },
                    new QueryArgument<StringGraphType>() { Name = "fkColumn", Description = "The optional foreign key column name in which to join" },
                    new QueryArgument<StringGraphType>() { Name = "fkProperty1Name", Description = "The optional foreign key primary property name" },
                    new QueryArgument<StringGraphType>() { Name = "fkProperty2Name", Description = "The optional foreign key secondary property name" }
                ),
                resolve: context => data.GetDifficultyLevelDistinctValues(
                    context.GetArgument<string>("keyName"),
                    context.GetArgument<string>("where"),
                    context.GetArgument<List<KnightsTour.CoreLibrary.TableJoin>>("tableJoins"),
                    context.GetArgument<string>("fkTable"),
                    context.GetArgument<string>("fkColumn"),
                    context.GetArgument<string>("fkProperty1Name"),
                    context.GetArgument<string>("fkProperty2Name"))
            );
            #endregion

            #region EventHistory related
            // Single event history.
            Field<EventHistoryType>(
                name: "eventHistory",
                description: "Returns a single Event history based on the primary key identifier",
                arguments: new QueryArguments(
                    new QueryArgument<NonNullGraphType<IntGraphType>> { Name = "id", Description = "id of the event history" }
                ),
                resolve: context => data.GetEventHistoryByIdAsync(context.GetArgument<int?>("id"))
            );

            // Multiple event histories.
            Field<ListGraphType<EventHistoryType>>(
                name: "eventHistories",
                description: "Returns a list of Event histories records given the optional filters",
                arguments: new QueryArguments(
                    new QueryArgument<StringGraphType>() { Name = "where", Description = "The SQL where clause to be applied." },
                    new QueryArgument<StringGraphType>() { Name = "orderBy", Description = "The SQL order by clause to be applied, can be complex (mutiple columns, directions)." },
                    new QueryArgument<IntGraphType>() { Name = "take", Description = "The number of event histories to return - typically used to limit or paginate results."},
                    new QueryArgument<IntGraphType>() { Name = "skip", Description = "The numer of event histories to skip (typically used for pagination)." },
                    new QueryArgument<ListGraphType<TableJoinInput>>() { Name = "tableJoins", Description = "The optional tables that this query joins on." }
                ),
                resolve: context => data.GetEventHistories(
                    context.GetArgument<string>("where"),
                    context.GetArgument<string>("orderBy"),
                    context.GetArgument<int?>("take"),
                    context.GetArgument<int?>("skip"),
                    context.GetArgument<List<KnightsTour.CoreLibrary.TableJoin>>("tableJoins"))
            );

            // Event history Count.
            Field<IntGraphType>(
                name: "eventHistoryCount",
                description: "The numer of Event history records given the optional where clause",
                arguments: new QueryArguments(
                    new QueryArgument<StringGraphType>() { Name = "where", Description = "The optional where clause to filter on" },
                    new QueryArgument<ListGraphType<TableJoinInput>>() { Name = "tableJoins", Description = "The optional tables that this query joins on." }
                ),
                resolve: context => data.GetEventHistoryCount(
                    context.GetArgument<string>("where"),
                    context.GetArgument<List<KnightsTour.CoreLibrary.TableJoin>>("tableJoins"))
            );

            // Distinct event history field grouping.
            Field<ListGraphType<GroupDetailType>>(
                name: "eventHistoryDistinctValues",
                description: "Returns a distinct list of column data for the specified column also applying the optional where clause",
                arguments: new QueryArguments(
                    new QueryArgument<StringGraphType>() { Name = "keyName", Description = "The column to return a distinct list of" },
                    new QueryArgument<StringGraphType>() { Name = "where", Description = "The optional where clause to filter on" },
                    new QueryArgument<ListGraphType<TableJoinInput>>() { Name = "tableJoins", Description = "The optional tables that this query joins on." },
                    new QueryArgument<StringGraphType>() { Name = "fkTable", Description = "The optional foreign key table name" },
                    new QueryArgument<StringGraphType>() { Name = "fkColumn", Description = "The optional foreign key column name in which to join" },
                    new QueryArgument<StringGraphType>() { Name = "fkProperty1Name", Description = "The optional foreign key primary property name" },
                    new QueryArgument<StringGraphType>() { Name = "fkProperty2Name", Description = "The optional foreign key secondary property name" }
                ),
                resolve: context => data.GetEventHistoryDistinctValues(
                    context.GetArgument<string>("keyName"),
                    context.GetArgument<string>("where"),
                    context.GetArgument<List<KnightsTour.CoreLibrary.TableJoin>>("tableJoins"),
                    context.GetArgument<string>("fkTable"),
                    context.GetArgument<string>("fkColumn"),
                    context.GetArgument<string>("fkProperty1Name"),
                    context.GetArgument<string>("fkProperty2Name"))
            );
            #endregion

            #region EventType related
            // Single event type.
            Field<EventTypeType>(
                name: "eventType",
                description: "Returns a single Event type based on the primary key identifier",
                arguments: new QueryArguments(
                    new QueryArgument<NonNullGraphType<IntGraphType>> { Name = "id", Description = "id of the event type" }
                ),
                resolve: context => data.GetEventTypeByIdAsync(context.GetArgument<int?>("id"))
            );

            // Multiple event types.
            Field<ListGraphType<EventTypeType>>(
                name: "eventTypes",
                description: "Returns a list of Event types records given the optional filters",
                arguments: new QueryArguments(
                    new QueryArgument<StringGraphType>() { Name = "where", Description = "The SQL where clause to be applied." },
                    new QueryArgument<StringGraphType>() { Name = "orderBy", Description = "The SQL order by clause to be applied, can be complex (mutiple columns, directions)." },
                    new QueryArgument<IntGraphType>() { Name = "take", Description = "The number of event types to return - typically used to limit or paginate results."},
                    new QueryArgument<IntGraphType>() { Name = "skip", Description = "The numer of event types to skip (typically used for pagination)." },
                    new QueryArgument<ListGraphType<TableJoinInput>>() { Name = "tableJoins", Description = "The optional tables that this query joins on." }
                ),
                resolve: context => data.GetEventTypes(
                    context.GetArgument<string>("where"),
                    context.GetArgument<string>("orderBy"),
                    context.GetArgument<int?>("take"),
                    context.GetArgument<int?>("skip"),
                    context.GetArgument<List<KnightsTour.CoreLibrary.TableJoin>>("tableJoins"))
            );

            // Event type Count.
            Field<IntGraphType>(
                name: "eventTypeCount",
                description: "The numer of Event type records given the optional where clause",
                arguments: new QueryArguments(
                    new QueryArgument<StringGraphType>() { Name = "where", Description = "The optional where clause to filter on" },
                    new QueryArgument<ListGraphType<TableJoinInput>>() { Name = "tableJoins", Description = "The optional tables that this query joins on." }
                ),
                resolve: context => data.GetEventTypeCount(
                    context.GetArgument<string>("where"),
                    context.GetArgument<List<KnightsTour.CoreLibrary.TableJoin>>("tableJoins"))
            );

            // Distinct event type field grouping.
            Field<ListGraphType<GroupDetailType>>(
                name: "eventTypeDistinctValues",
                description: "Returns a distinct list of column data for the specified column also applying the optional where clause",
                arguments: new QueryArguments(
                    new QueryArgument<StringGraphType>() { Name = "keyName", Description = "The column to return a distinct list of" },
                    new QueryArgument<StringGraphType>() { Name = "where", Description = "The optional where clause to filter on" },
                    new QueryArgument<ListGraphType<TableJoinInput>>() { Name = "tableJoins", Description = "The optional tables that this query joins on." },
                    new QueryArgument<StringGraphType>() { Name = "fkTable", Description = "The optional foreign key table name" },
                    new QueryArgument<StringGraphType>() { Name = "fkColumn", Description = "The optional foreign key column name in which to join" },
                    new QueryArgument<StringGraphType>() { Name = "fkProperty1Name", Description = "The optional foreign key primary property name" },
                    new QueryArgument<StringGraphType>() { Name = "fkProperty2Name", Description = "The optional foreign key secondary property name" }
                ),
                resolve: context => data.GetEventTypeDistinctValues(
                    context.GetArgument<string>("keyName"),
                    context.GetArgument<string>("where"),
                    context.GetArgument<List<KnightsTour.CoreLibrary.TableJoin>>("tableJoins"),
                    context.GetArgument<string>("fkTable"),
                    context.GetArgument<string>("fkColumn"),
                    context.GetArgument<string>("fkProperty1Name"),
                    context.GetArgument<string>("fkProperty2Name"))
            );
            #endregion

            #region Member related
            // Single member.
            Field<MemberType>(
                name: "member",
                description: "Returns a single Member based on the primary key identifier",
                arguments: new QueryArguments(
                    new QueryArgument<NonNullGraphType<IntGraphType>> { Name = "id", Description = "id of the member" }
                ),
                resolve: context => data.GetMemberByIdAsync(context.GetArgument<int?>("id"))
            );

            // Multiple members.
            Field<ListGraphType<MemberType>>(
                name: "members",
                description: "Returns a list of Members records given the optional filters",
                arguments: new QueryArguments(
                    new QueryArgument<StringGraphType>() { Name = "where", Description = "The SQL where clause to be applied." },
                    new QueryArgument<StringGraphType>() { Name = "orderBy", Description = "The SQL order by clause to be applied, can be complex (mutiple columns, directions)." },
                    new QueryArgument<IntGraphType>() { Name = "take", Description = "The number of members to return - typically used to limit or paginate results."},
                    new QueryArgument<IntGraphType>() { Name = "skip", Description = "The numer of members to skip (typically used for pagination)." },
                    new QueryArgument<ListGraphType<TableJoinInput>>() { Name = "tableJoins", Description = "The optional tables that this query joins on." }
                ),
                resolve: context => data.GetMembers(
                    context.GetArgument<string>("where"),
                    context.GetArgument<string>("orderBy"),
                    context.GetArgument<int?>("take"),
                    context.GetArgument<int?>("skip"),
                    context.GetArgument<List<KnightsTour.CoreLibrary.TableJoin>>("tableJoins"))
            );

            // Member Count.
            Field<IntGraphType>(
                name: "memberCount",
                description: "The numer of Member records given the optional where clause",
                arguments: new QueryArguments(
                    new QueryArgument<StringGraphType>() { Name = "where", Description = "The optional where clause to filter on" },
                    new QueryArgument<ListGraphType<TableJoinInput>>() { Name = "tableJoins", Description = "The optional tables that this query joins on." }
                ),
                resolve: context => data.GetMemberCount(
                    context.GetArgument<string>("where"),
                    context.GetArgument<List<KnightsTour.CoreLibrary.TableJoin>>("tableJoins"))
            );

            // Distinct member field grouping.
            Field<ListGraphType<GroupDetailType>>(
                name: "memberDistinctValues",
                description: "Returns a distinct list of column data for the specified column also applying the optional where clause",
                arguments: new QueryArguments(
                    new QueryArgument<StringGraphType>() { Name = "keyName", Description = "The column to return a distinct list of" },
                    new QueryArgument<StringGraphType>() { Name = "where", Description = "The optional where clause to filter on" },
                    new QueryArgument<ListGraphType<TableJoinInput>>() { Name = "tableJoins", Description = "The optional tables that this query joins on." },
                    new QueryArgument<StringGraphType>() { Name = "fkTable", Description = "The optional foreign key table name" },
                    new QueryArgument<StringGraphType>() { Name = "fkColumn", Description = "The optional foreign key column name in which to join" },
                    new QueryArgument<StringGraphType>() { Name = "fkProperty1Name", Description = "The optional foreign key primary property name" },
                    new QueryArgument<StringGraphType>() { Name = "fkProperty2Name", Description = "The optional foreign key secondary property name" }
                ),
                resolve: context => data.GetMemberDistinctValues(
                    context.GetArgument<string>("keyName"),
                    context.GetArgument<string>("where"),
                    context.GetArgument<List<KnightsTour.CoreLibrary.TableJoin>>("tableJoins"),
                    context.GetArgument<string>("fkTable"),
                    context.GetArgument<string>("fkColumn"),
                    context.GetArgument<string>("fkProperty1Name"),
                    context.GetArgument<string>("fkProperty2Name"))
            );
            #endregion

            #region Puzzle related
            // Single puzzle.
            Field<PuzzleType>(
                name: "puzzle",
                description: "Returns a single Puzzle based on the primary key identifier",
                arguments: new QueryArguments(
                    new QueryArgument<NonNullGraphType<IntGraphType>> { Name = "id", Description = "id of the puzzle" }
                ),
                resolve: context => data.GetPuzzleByIdAsync(context.GetArgument<int?>("id"))
            );

            // Multiple puzzles.
            Field<ListGraphType<PuzzleType>>(
                name: "puzzles",
                description: "Returns a list of Puzzles records given the optional filters",
                arguments: new QueryArguments(
                    new QueryArgument<StringGraphType>() { Name = "where", Description = "The SQL where clause to be applied." },
                    new QueryArgument<StringGraphType>() { Name = "orderBy", Description = "The SQL order by clause to be applied, can be complex (mutiple columns, directions)." },
                    new QueryArgument<IntGraphType>() { Name = "take", Description = "The number of puzzles to return - typically used to limit or paginate results."},
                    new QueryArgument<IntGraphType>() { Name = "skip", Description = "The numer of puzzles to skip (typically used for pagination)." },
                    new QueryArgument<ListGraphType<TableJoinInput>>() { Name = "tableJoins", Description = "The optional tables that this query joins on." }
                ),
                resolve: context => data.GetPuzzles(
                    context.GetArgument<string>("where"),
                    context.GetArgument<string>("orderBy"),
                    context.GetArgument<int?>("take"),
                    context.GetArgument<int?>("skip"),
                    context.GetArgument<List<KnightsTour.CoreLibrary.TableJoin>>("tableJoins"))
            );

            // Puzzle Count.
            Field<IntGraphType>(
                name: "puzzleCount",
                description: "The numer of Puzzle records given the optional where clause",
                arguments: new QueryArguments(
                    new QueryArgument<StringGraphType>() { Name = "where", Description = "The optional where clause to filter on" },
                    new QueryArgument<ListGraphType<TableJoinInput>>() { Name = "tableJoins", Description = "The optional tables that this query joins on." }
                ),
                resolve: context => data.GetPuzzleCount(
                    context.GetArgument<string>("where"),
                    context.GetArgument<List<KnightsTour.CoreLibrary.TableJoin>>("tableJoins"))
            );

            // Distinct puzzle field grouping.
            Field<ListGraphType<GroupDetailType>>(
                name: "puzzleDistinctValues",
                description: "Returns a distinct list of column data for the specified column also applying the optional where clause",
                arguments: new QueryArguments(
                    new QueryArgument<StringGraphType>() { Name = "keyName", Description = "The column to return a distinct list of" },
                    new QueryArgument<StringGraphType>() { Name = "where", Description = "The optional where clause to filter on" },
                    new QueryArgument<ListGraphType<TableJoinInput>>() { Name = "tableJoins", Description = "The optional tables that this query joins on." },
                    new QueryArgument<StringGraphType>() { Name = "fkTable", Description = "The optional foreign key table name" },
                    new QueryArgument<StringGraphType>() { Name = "fkColumn", Description = "The optional foreign key column name in which to join" },
                    new QueryArgument<StringGraphType>() { Name = "fkProperty1Name", Description = "The optional foreign key primary property name" },
                    new QueryArgument<StringGraphType>() { Name = "fkProperty2Name", Description = "The optional foreign key secondary property name" }
                ),
                resolve: context => data.GetPuzzleDistinctValues(
                    context.GetArgument<string>("keyName"),
                    context.GetArgument<string>("where"),
                    context.GetArgument<List<KnightsTour.CoreLibrary.TableJoin>>("tableJoins"),
                    context.GetArgument<string>("fkTable"),
                    context.GetArgument<string>("fkColumn"),
                    context.GetArgument<string>("fkProperty1Name"),
                    context.GetArgument<string>("fkProperty2Name"))
            );
            #endregion

            #region Solution related
            // Single solution.
            Field<SolutionType>(
                name: "solution",
                description: "Returns a single Solution based on the primary key identifier",
                arguments: new QueryArguments(
                    new QueryArgument<NonNullGraphType<IntGraphType>> { Name = "id", Description = "id of the solution" }
                ),
                resolve: context => data.GetSolutionByIdAsync(context.GetArgument<int?>("id"))
            );

            // Multiple solutions.
            Field<ListGraphType<SolutionType>>(
                name: "solutions",
                description: "Returns a list of Solutions records given the optional filters",
                arguments: new QueryArguments(
                    new QueryArgument<StringGraphType>() { Name = "where", Description = "The SQL where clause to be applied." },
                    new QueryArgument<StringGraphType>() { Name = "orderBy", Description = "The SQL order by clause to be applied, can be complex (mutiple columns, directions)." },
                    new QueryArgument<IntGraphType>() { Name = "take", Description = "The number of solutions to return - typically used to limit or paginate results."},
                    new QueryArgument<IntGraphType>() { Name = "skip", Description = "The numer of solutions to skip (typically used for pagination)." },
                    new QueryArgument<ListGraphType<TableJoinInput>>() { Name = "tableJoins", Description = "The optional tables that this query joins on." }
                ),
                resolve: context => data.GetSolutions(
                    context.GetArgument<string>("where"),
                    context.GetArgument<string>("orderBy"),
                    context.GetArgument<int?>("take"),
                    context.GetArgument<int?>("skip"),
                    context.GetArgument<List<KnightsTour.CoreLibrary.TableJoin>>("tableJoins"))
            );

            // Solution Count.
            Field<IntGraphType>(
                name: "solutionCount",
                description: "The numer of Solution records given the optional where clause",
                arguments: new QueryArguments(
                    new QueryArgument<StringGraphType>() { Name = "where", Description = "The optional where clause to filter on" },
                    new QueryArgument<ListGraphType<TableJoinInput>>() { Name = "tableJoins", Description = "The optional tables that this query joins on." }
                ),
                resolve: context => data.GetSolutionCount(
                    context.GetArgument<string>("where"),
                    context.GetArgument<List<KnightsTour.CoreLibrary.TableJoin>>("tableJoins"))
            );

            // Distinct solution field grouping.
            Field<ListGraphType<GroupDetailType>>(
                name: "solutionDistinctValues",
                description: "Returns a distinct list of column data for the specified column also applying the optional where clause",
                arguments: new QueryArguments(
                    new QueryArgument<StringGraphType>() { Name = "keyName", Description = "The column to return a distinct list of" },
                    new QueryArgument<StringGraphType>() { Name = "where", Description = "The optional where clause to filter on" },
                    new QueryArgument<ListGraphType<TableJoinInput>>() { Name = "tableJoins", Description = "The optional tables that this query joins on." },
                    new QueryArgument<StringGraphType>() { Name = "fkTable", Description = "The optional foreign key table name" },
                    new QueryArgument<StringGraphType>() { Name = "fkColumn", Description = "The optional foreign key column name in which to join" },
                    new QueryArgument<StringGraphType>() { Name = "fkProperty1Name", Description = "The optional foreign key primary property name" },
                    new QueryArgument<StringGraphType>() { Name = "fkProperty2Name", Description = "The optional foreign key secondary property name" }
                ),
                resolve: context => data.GetSolutionDistinctValues(
                    context.GetArgument<string>("keyName"),
                    context.GetArgument<string>("where"),
                    context.GetArgument<List<KnightsTour.CoreLibrary.TableJoin>>("tableJoins"),
                    context.GetArgument<string>("fkTable"),
                    context.GetArgument<string>("fkColumn"),
                    context.GetArgument<string>("fkProperty1Name"),
                    context.GetArgument<string>("fkProperty2Name"))
            );
            #endregion

        }
        #endregion Constructor(s)

    } // Class
} // Namespace