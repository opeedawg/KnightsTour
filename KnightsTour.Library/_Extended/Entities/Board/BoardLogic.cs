// Â© 2023 27 Software
//
// ************************************************************************
// Author           : DXterity8 Version 8.6
// Created          : January 13, 2023 7:25:01 AM
// File             : BoardLogic.cs
// ************************************************************************

using KnightsTour.CoreLibrary;
using KnightsTour.Models;
using System;
using System.Collections.Generic;
using System.Data;
using System.Linq;
using System.Security.Policy;

namespace KnightsTour
{
    /// <summary>
    /// Auto generated from DB table Board
    /// Generated On: January 13, 2023 at 7:25:01 AM by DXterity Solutions.
    /// Generated By: DXterity8 Version 8.6.0 (see https://dxteritysolutions.com/).
    /// </summary>
    /// <remarks>
    /// Use this class to manage and extend the generated logic related to the <see cref="Board"/> class.
    /// This class is only regenerated if it is detected that it has never been modified.
    /// </remarks>
    public class BoardLogic : BoardLogicBase
    {
        #region Extended Constructor(s)

        /// <summary>
        /// Initializes a new instance of the <see cref="BoardLogic"/> class.
        /// Instantiates a new generic LogicBase class using the configured repository.
        /// </summary>
        /// <param name="userName">The user using this class.</param>
        /// <example>
        /// <code>
        /// BoardLogicBase BoardLogic = new BoardLogic(userName);
        /// </code>
        /// </example>
        public BoardLogic(string userName) : base(userName)
        {
        }
        /// <summary>
        /// Initializes a new instance of the <see cref="BoardLogic"/> class.
        /// Instantiates a new generic LogicBase class using the passed handler.
        /// </summary>
        /// <param name="handler">A storage handler.</param>
        /// <param name="userName">The user using this class.</param>
        public BoardLogic(KnightsTour.CoreLibrary.IStorageHandler handler, string userName) : base(handler, userName)
        {
        }
        #endregion Extended Constructor(s)

        #region Extended Declarations
        #endregion Extended Declarations

        #region Extended Properties
        #endregion Extended Properties

        #region Extended Methods
        public bool PathExists(string path)
        {
            StorageStatement statement = new StorageStatement()
            {
                Statement = $"SELECT COUNT(0) FROM [Board] WHERE Path = {StorageProvider.GetParameterPrefix()}path",
                Parameter = new GenericParameter($"{StorageProvider.GetParameterPrefix()}path", path),
            };

            IStorageHandler handler = StorageProvider.GetHandler();

            return handler.GetValue<int>(statement) > 0;
        }
        /// <summary>
        /// Executes a custom action against the Board given the passed ids.
        /// </summary>
        /// <param name="actionName">The name of the custom operation to execute.</param>
        /// <param name="ids">The comma delimited list of id(s) of the objects on which to execute the custom operation.</param>
        /// <returns><see cref="KnightsTour.CoreLibrary.IActionResponse"/>: A populated rich response object.</returns>
        public KnightsTour.CoreLibrary.IActionResponse DoCustomAction(string actionName, string ids)
        {
            KnightsTour.CoreLibrary.IActionResponse response = new KnightsTour.CoreLibrary.ActionResponse($"Do custom action: '{actionName}'");

            // Some parameter validations.
            if (string.IsNullOrEmpty(actionName))
            {
                response.Append(new Exception("Missing mandatory parameter 'actionName' in BoardLogic.DoCustomAction"));
            }
            if (string.IsNullOrEmpty(ids))
            {
                response.Append(new Exception("Missing mandatory parameter 'ids' in BoardLogic.DoCustomAction"));
            }

            if (response.IsValid)
            {
                // Get a distinct list of non-empty ids.
                List<string> idList = ids.Split(',').ToList().Where(s => !string.IsNullOrWhiteSpace(s)).Distinct().ToList();

                if (idList.Count > 0)
                {
                    // Validate that this action exists.
                    switch (actionName)
                    {
                        // As this is extended code, as you configure new custom actions or remove them, you will need to maintain the case statement manually.

                        default:
                            response.Append(new Exception($"Unknown or unhandled action type '{actionName}'"));
                            break;

                    }
                }
            }

            // Return the response.
            return response;
        }
        public IActionResponse FixBoardDimmensions()
        {
            IActionResponse response = new ActionResponse("Board transformation");

            try
            {
                foreach (Board board in GetAll())
                {
                    if (!board.IsSquare)
                    {
                        // Validate and resolve any reversed rows and columns count.
                        board.RowDimension = board.DeserializedPath.Count;
                        if (board.RowDimension > 0)
                        {
                            board.ColDimension = board.DeserializedPath[0].Count;
                        }
                    }

                    // Verify the path is properly serialized.
                    board.Path = board.SerializedPath;

                    if (board.IsModified())
                    {
                        RaiseResponse(Update(board));
                    }
                    else
                    {
                        RaiseMessage(new Message($"Board {board.BoardId} validated."));
                    }
                }
            }
            catch (Exception exception)
            {
                RaiseException(exception);
            }

            return response;
        }
        public IActionResponse CreateAllBoardTransformations()
        {
            IActionResponse response = new ActionResponse("Board transformation");

            try
            {
                List<Board> originalBoards = GetAll().Where(b => !b.SourceBoardId.HasValue).ToList();

                foreach (Board originalBoard in originalBoards)
                {
                    #region Rotate 90 degrees
                    Board boardCopy = originalBoard.Clone();
                    boardCopy.RotateBoard(originalBoard.BoardId.Value);
                    bool newTransformationCreated = false;
                    if(!PathExists(boardCopy.Path))
                    {
                        RaiseResponse(Insert(boardCopy));
                        newTransformationCreated = true;
                    }
                    #endregion

                    #region Rotate 180 degrees
                    boardCopy = originalBoard.Clone();
                    boardCopy.RotateBoard(originalBoard.BoardId.Value);
                    boardCopy.RotateBoard(originalBoard.BoardId.Value);

                    if (!PathExists(boardCopy.Path))
                    {
                        RaiseResponse(Insert(boardCopy));
                        newTransformationCreated = true;
                    }
                    #endregion

                    #region Rotate 270 degrees
                    boardCopy = originalBoard.Clone();
                    boardCopy.RotateBoard(originalBoard.BoardId.Value);
                    boardCopy.RotateBoard(originalBoard.BoardId.Value);
                    boardCopy.RotateBoard(originalBoard.BoardId.Value);

                    if (!PathExists(boardCopy.Path))
                    {
                        RaiseResponse(Insert(boardCopy));
                        newTransformationCreated = true;
                    }

                    if (!newTransformationCreated)
                        RaiseUpdate($"No new transformation required to be creatd for {originalBoard.ShortDescription}.");
                    #endregion
                }
            }
            catch (Exception exception)
            {
                RaiseException(exception);
            }

            return response;
        }
        public IActionResponse CreatePuzzles(int quantity = 10, bool forceRefresh = false)
        {
            IActionResponse response = new ActionResponse("Creating all puzzles");
            foreach (Board board in GetAll())
            {
                response.Append(CreatePuzzles(board, quantity, forceRefresh));
            }

            return response;
        }
        public IActionResponse CreatePuzzles(int boardId, int quantity = 10, bool forceRefresh = false)
        {
            return CreatePuzzles(GetById(boardId), quantity, forceRefresh);
        }
        public IActionResponse CreatePuzzles(Board board, int puzzlesToCreate, bool forceRefresh)
        {
            IActionResponse response = new ActionResponse("Creating puzzles");
            PuzzleLogic pLogic = new PuzzleLogic(UserName);

            #region Remove previous puzzles if asked to do so.
            int existingPuzzleCount = 0;
            if (forceRefresh)
            {
                StorageStatement statement = new StorageStatement()
                {
                    Statement = $"DELETE FROM [Puzzle] WHERE BoardId = {StorageProvider.GetParameterPrefix()}boardId",
                    Parameter = new GenericParameter($"{StorageProvider.GetParameterPrefix()}boardId", board.BoardId.Value),
                };

                IStorageHandler handler = StorageProvider.GetHandler();

                RaiseMessage(new Message($"{handler.Execute(statement)} existing puzzles removed."));
            }
            else
            {
                StorageStatement statement = new StorageStatement()
                {
                    Statement = $"SELECT COUNT(0) FROM [Puzzle] WHERE BoardId = {StorageProvider.GetParameterPrefix()}boardId",
                    Parameter = new GenericParameter($"{StorageProvider.GetParameterPrefix()}boardId", board.BoardId.Value),
                };

                IStorageHandler handler = StorageProvider.GetHandler();
                existingPuzzleCount = handler.GetValue<int>(statement);
            }
            #endregion

            List<DifficultyLevel> allLevels = new DifficultyLevelLogic(UserName).GetAll().Where(l => board.ColDimension >= l.MinimumDimension && board.ColDimension >= l.MinimumDimension && board.ColDimension <= l.MaximumDimension && board.RowDimension <= l.MaximumDimension).ToList();
            if (existingPuzzleCount < allLevels.Count * puzzlesToCreate)
            {
                foreach (DifficultyLevel level in allLevels)
                {
                    Board boardClone = board.Clone();

                    int puzzlesCreated = GetExistingPuzzleCount(board.BoardId.Value, level.DifficultyLevelId.Value);
                    while (puzzlesCreated < puzzlesToCreate)
                    {
                        string puzzlePath = MakePuzzle(boardClone, level);

                        if (!pLogic.PathExists(puzzlePath))
                        {
                            Puzzle puzzle = new Puzzle();
                            puzzle.BoardId = board.BoardId;
                            puzzle.DifficultyLevelId = level.DifficultyLevelId;
                            puzzle.Path = puzzlePath;
                            puzzle.PuzzleOfTheDayDate = null;

                            RaiseResponse(pLogic.Insert(puzzle));

                            puzzlesCreated++;
                        }
                        else
                        {
                            RaiseMessage(new Message($"Duplicate path found for board {board.BoardId} level {level.Name}: {puzzlePath}", CoreLibrary.Enumerations.MessageType.Information));
                        }
                    }
                }
            }
            else
            {
                RaiseUpdate($"Maximum solutions requested ({puzzlesToCreate}) already created for all levels ({allLevels.Count}) for board {board.ShortDescription}.");
            }

            return response;
        }
        int GetExistingPuzzleCount(int boardId, int difficultyLevelId)
        {
            StorageStatement statement = new StorageStatement()
            {
                Statement = $"SELECT COUNT(0) FROM [Puzzle] WHERE BoardId = {StorageProvider.GetParameterPrefix()}boardId AND DifficultyLevelId = {StorageProvider.GetParameterPrefix()}difficultyLevelId",
                Parameters = new List<IParameter>(){
                    new GenericParameter($"{StorageProvider.GetParameterPrefix()}boardId", boardId),
                    new GenericParameter($"{StorageProvider.GetParameterPrefix()}difficultyLevelId", difficultyLevelId),
                }
            };

            IStorageHandler handler = StorageProvider.GetHandler();
            return handler.GetValue<int>(statement);
        }

        string MakePuzzle(Board solvedBoard, DifficultyLevel level)
        {
            int squaresToRemove = solvedBoard.TotalSquares - (int)((double)level.PercentVisibility * solvedBoard.TotalSquares);
            int maximumGap = level.MaximumGap;

            Board newPuzzleBoard = GetValidPuzzleBoardBase(solvedBoard, squaresToRemove, maximumGap);

            return newPuzzleBoard.SerializedPath;
        }

        Board GetValidPuzzleBoardBase(Board sourceBoard, long squaresToRemove, int maximumGap)
        {
            Random rand = new Random();
            int currentMaxGap = -1;
            int currentIteration = 0;
            int maximumIterations = 1000000;
            while (currentIteration < maximumIterations)
            {
                List<List<int>> puzzleValues = new List<List<int>>();

                int totalSquaresRemoved = 0;
                Board puzzleBoard = sourceBoard.Clone();
                while (totalSquaresRemoved < squaresToRemove - 1)
                {
                    int randCol = rand.Next(puzzleBoard.ColDimension);
                    int randRow = rand.Next(puzzleBoard.RowDimension);
                    int value = puzzleBoard.DeserializedPath[randRow][randCol];
                    if (
                        value != KnightTourSquare.AVAILABLE_SQUARE &&
                        value != KnightTourSquare.AVAILABLE_SQUARE + 1 &&
                        value != puzzleBoard.TotalSquares)
                    {
                        puzzleBoard.DeserializedPath[randRow][randCol] = KnightTourSquare.AVAILABLE_SQUARE;
                        totalSquaresRemoved++;
                    }
                }

                currentMaxGap = GetMaximumGap(puzzleBoard.DeserializedPath);

                if (currentMaxGap <= maximumGap)
                    return puzzleBoard;

                currentIteration++;
            }

            throw new Exception($"Maximum iterations ({maximumIterations}) reached for board {sourceBoard.BoardId}. Check for bugs or increase iterations.");
        }
        int GetMaximumGap(List<List<int>> baseSquares)
        {
            List<int> distinctValues = new List<int>();
            for (int i = 0; i < baseSquares.Count; i++)
            {
                for (int j = 0; j < baseSquares[0].Count; j++)
                {
                    if (!distinctValues.Contains(baseSquares[i][j]))
                        distinctValues.Add(baseSquares[i][j]);
                }
            }

            distinctValues = distinctValues.OrderBy(v => v).ToList();

            int maxGap = 0;
            for (int i = 0; i < distinctValues.Count - 1; i++)
            {
                int gap = distinctValues[i + 1] - distinctValues[i];
                if (gap > maxGap)
                    maxGap = gap;
            }

            return maxGap;
        }
        public IActionResponse GetBoardSizes()
        { 
            IActionResponse response = new ActionResponse();

            try
            {
                List<SelectOption> options = new List<SelectOption>();
                foreach (IDataRecord row in StorageHandler.GetRecords(new StorageStatement()
                {
                    Statement = "SELECT * FROM [V_DistinctBoardSizes] ORDER BY ColDimension, RowDimension"
                }))
                {
                    options.Add(new SelectOption(row.GetValue(2).ToString(), $"{row.GetValue(2)} ({row.GetValue(3)} puzzles)"));
                }

                response.Append(new Message($"{options.Count} board sizes retrieved."));
                response.DataObject = options;
            }
            catch (Exception exception)
            {
                response.Append(exception);
            }

            return response;
        }
        #endregion Extended Methods

        #region Event Relates
        public delegate void NewLogicEventHandler(object sender, LogicEventArgs args);
        public event NewLogicEventHandler OnUpdate;
        protected virtual void RaiseResponse(IActionResponse response)
        {
            foreach(Message message in response.Messages)
                OnUpdate?.Invoke(this, new LogicEventArgs(message));
        }
        protected virtual void RaiseUpdate(string message)
        {
            OnUpdate?.Invoke(this, new LogicEventArgs(message));
        }
        protected virtual void RaiseMessage(Message message)
        {
            OnUpdate?.Invoke(this, new LogicEventArgs(message));
        }
        protected virtual void RaiseException(Exception exception)
        {
            OnUpdate?.Invoke(this, new LogicEventArgs(exception));
        }
        public class LogicEventArgs : EventArgs
        {
            public LogicEventArgs(string message): this(new Message(message, CoreLibrary.Enumerations.MessageType.Information))
            {
            }
            public LogicEventArgs(Exception exception): this(new Message(exception.Message, CoreLibrary.Enumerations.MessageType.Negative))
            {
            }
            public LogicEventArgs(Message message)
            {
                Message = message;
            }

            public Message Message { get; private set; }
        }
        #endregion

    } // Class
} // Namespace